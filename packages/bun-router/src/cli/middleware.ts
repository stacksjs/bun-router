import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import chalk from 'chalk'
import { middleware } from '../../src/middleware'

/**
 * Options for the middleware:types command
 */
export interface GenerateMiddlewareTypesOptions {
  output?: string
  watch?: boolean
}

/**
 * Generate TypeScript types for middleware configurations
 */
export async function generateMiddlewareTypes(outputPath: string): Promise<void> {
  // Get middleware information
  const middlewareInfo = Object.entries(middleware).map(([key, instance]) => ({
    name: key,
    className: instance.constructor.name,
  }))

  // Generate type definition
  const typeContent = `/**
 * This file is auto-generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update, run 'bun router middleware:types'
 */
import type { ${middlewareInfo.map(m => m.className).join(', ')} } from './middleware'

/**
 * Available middleware map with middleware names as keys
 */
export interface MiddlewareMap {
${middlewareInfo.map(m => `  '${m.name}': ${m.className}`).join('\n')}
}

/**
 * String literal type of available middleware names
 */
export type MiddlewareName = ${middlewareInfo.map(m => `'${m.name}'`).join(' | ')}

/**
 * Middleware configuration type for router setup
 */
export type MiddlewareConfig = MiddlewareName | ${middlewareInfo.map(m => m.className).join(' | ')}

/**
 * Function to check if a middleware name is valid
 */
export function isValidMiddleware(name: string): name is MiddlewareName {
  return [${middlewareInfo.map(m => `'${m.name}'`).join(', ')}].includes(name)
}
`

  // Write to file
  await fs.writeFile(outputPath, typeContent)
}

/**
 * Watch for changes in the middleware directory and regenerate types
 */
export async function watchMiddlewareDirectory(outputPath: string): Promise<void> {
  const middlewarePath = path.join(process.cwd(), 'src', 'middleware')

  // Check if middleware directory exists
  try {
    await fs.access(middlewarePath)
  }
  catch {
    console.error(chalk.red(`Middleware directory not found at ${middlewarePath}`))
    process.exit(1)
  }

  // Initial generation
  await generateMiddlewareTypes(outputPath)
  console.log(chalk.green(`✨ Middleware types generated at ${outputPath}`))
  console.log(chalk.blue(`Watching for changes in ${middlewarePath}...`))

  // Setup file watcher
  let timeoutId: NodeJS.Timeout | null = null
  const watcher = fs.watch(middlewarePath, { recursive: true })

  for await (const _event of watcher) {
    // Debounce to avoid multiple regenerations when multiple files change
    if (timeoutId) {
      clearTimeout(timeoutId)
    }

    timeoutId = setTimeout(async () => {
      console.log(chalk.yellow(`Changes detected in middleware directory. Regenerating types...`))
      try {
        await generateMiddlewareTypes(outputPath)
        console.log(chalk.green(`✨ Middleware types regenerated at ${outputPath}`))
      }
      catch (error: any) {
        console.error(chalk.red(`Error regenerating types: ${error.message}`))
      }
      timeoutId = null
    }, 500)
  }
}
