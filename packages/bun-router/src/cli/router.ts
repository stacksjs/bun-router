import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import chalk from 'chalk'

/**
 * Options for the router:types command
 */
export interface GenerateRouterTypesOptions {
  output?: string
  watch?: boolean
}

/**
 * Generate TypeScript types for router extensions
 */
export async function generateRouterTypes(outputPath: string): Promise<void> {
  try {
    // Try to load router instance from the application
    const routesFile = `${process.cwd()}/routes/index.ts`
    const { router } = await import(routesFile)

    if (!router) {
      console.error(chalk.red(`Could not find router instance in ${routesFile}.`))
      process.exit(1)
    }

    // Get router methods excluding internal properties
    const routerMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(router))
      .filter(method =>
        !method.startsWith('_')
        && method !== 'constructor'
        && typeof (router as any)[method] === 'function',
      )

    // Get custom properties that were added to router
    const extendedProperties = Object.keys(router)
      .filter(prop =>
        !['routes', 'middleware', 'hooks', 'config'].includes(prop)
        && typeof prop === 'string'
        && !prop.startsWith('_'),
      )

    // Generate type definition
    const typeContent = `/**
 * This file is auto-generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update, run 'bun router router:types'
 */
import type { Router, RouteHandler, MiddlewareHandler, RouteDefinition } from '../src/types'

/**
 * Extended Router interface with all available methods and properties
 */
export interface ExtendedRouter extends Router {
  ${routerMethods.map((method) => {
    // Provide basic type definitions for common router methods
    if (['get', 'post', 'put', 'delete', 'patch', 'options', 'head'].includes(method)) {
      return `${method}(path: string, handler: RouteHandler, options?: any): Router`
    }
    else if (method === 'use') {
      return `${method}(middleware: MiddlewareHandler | MiddlewareHandler[]): Router`
    }
    else if (method === 'group') {
      return `${method}(prefix: string, callback: (router: Router) => void): Router`
    }
    else {
      return `${method}: Function`
    }
  }).join('\n  ')}

  ${extendedProperties.map((prop) => {
    const propType = typeof (router as any)[prop]
    return `${prop}: ${propType}`
  }).join('\n  ')}
}

/**
 * Type for extending the router with custom methods
 */
export type RouterExtension = {
  [key: string]: Function | any
}

/**
 * Helper type for correctly typing router extensions
 *
 * Example usage:
 * \`\`\`typescript
 * import { Router, ExtendRouter } from './router-types'
 *
 * // Define extension type
 * interface MyCustomRouter extends ExtendRouter<{
 *   customMethod(param: string): void
 * }> {}
 *
 * // Create and extend the router
 * const router = new Router() as MyCustomRouter
 * router.customMethod = (param: string) => {
 *   console.log(param)
 * }
 * \`\`\`
 */
export type ExtendRouter<T extends RouterExtension> = Router & T
`

    // Write to file
    await fs.writeFile(outputPath, typeContent)
    console.log(chalk.green(`✨ Router types generated at ${outputPath}`))
  }
  catch (error: any) {
    if (error.code === 'ERR_MODULE_NOT_FOUND') {
      console.error(chalk.red(`Routes file not found at ${process.cwd()}/routes/index.ts`))
      console.error(chalk.yellow('Make sure your routes are defined and exported as "router" in routes/index.ts'))
    }
    else {
      console.error(chalk.red(`Error generating router types: ${error.message}`))
    }
    throw error
  }
}

/**
 * Watch for changes in router files and regenerate types
 */
export async function watchRouterFiles(outputPath: string): Promise<void> {
  const routerFiles = [
    path.join(process.cwd(), 'routes'),
    path.join(process.cwd(), 'src'),
  ]

  // Check if at least one directory exists
  let validPath = false
  for (const dirPath of routerFiles) {
    try {
      await fs.access(dirPath)
      validPath = true
      break
    }
    catch {
      // Continue checking other paths
    }
  }

  if (!validPath) {
    console.error(chalk.red(`No valid source directories found to watch.`))
    process.exit(1)
  }

  // Initial generation
  await generateRouterTypes(outputPath)
  console.log(chalk.green(`✨ Router types generated at ${outputPath}`))
  console.log(chalk.blue(`Watching for changes in router files...`))

  // Setup file watchers for all paths
  let timeoutId: NodeJS.Timeout | null = null

  for (const dirPath of routerFiles) {
    try {
      const watcher = fs.watch(dirPath, { recursive: true })

      // Using IIFE to create separate async context for each watcher
      ;(async () => {
        for await (const _event of watcher) {
          // Debounce to avoid multiple regenerations when multiple files change
          if (timeoutId) {
            clearTimeout(timeoutId)
          }

          timeoutId = setTimeout(async () => {
            console.log(chalk.yellow(`Changes detected in router files. Regenerating types...`))
            try {
              await generateRouterTypes(outputPath)
              console.log(chalk.green(`✨ Router types regenerated at ${outputPath}`))
            }
            catch (error: any) {
              console.error(chalk.red(`Error regenerating types: ${error.message}`))
            }
            timeoutId = null
          }, 500)
        }
      })()
    }
    catch {
      // Skip if this path doesn't exist
    }
  }
}
